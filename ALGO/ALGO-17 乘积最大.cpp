/*
问题描述
　　今年是国际数学联盟确定的“2000――世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。
  在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。
  活动中，主持人给所有参加活动的选手出了这样一道题目：

  设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。

  同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：

	有一个数字串：312， 当N=3，K=1时会有以下两种分法：

	3*12=36
	31*2=62

	这时，符合题目要求的结果是：31*2=62

	现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。

输入格式
	程序的输入共有两行：
	第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）
	第二行是一个长度为N的数字串。

输出格式
	输出所求得的最大乘积（一个自然数）。

样例输入
	4 2
	1231
样例输出
	62
*/

/*
动态规划过程

思路是把前 i 个数字分割成 j 段，则将前 k 个数字分成 j-1段，将最后i - k个数字作为一段，那么两段的乘积作为前 i 个数字分割成 j 段的乘积，从中选取最大值作为dp[ i ][ j ]的值。

此时，k 个数字分成 j-1段位：dp[ k ][ j-1]，将最后i-k个数字作为一段：m[k+1][ i ] （即从k + 1到 i 所代表的数）

即： dp[ i ][ j ]=max{dp[ i ][ j ] , dp[ k ][ j-1]*m[ k+1][ i ]}

*/

#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;

int dp[41][7]; //dp[i][j]，前i个数字分成j段

int main()  
{  
	int n,k;
	int a[41];//存储每一位数字
	int m[41][41];//m[i][j]表示从i到j位数
	scanf("%d%d",&n,&k);
	for(int i=1; i<=n; i++){
		char ch;
		cin>>ch;
		a[i]=ch-'0';
	}

	memset(m, 0, sizeof(m));
	for(int i=1; i<=n; i++){
		m[i][i]=a[i];
	}
	for(int i=1; i<=n; i++){
		for(int j=i+1; j<=n; j++){
			m[i][j] = m[i][j-1]*10 + m[j][j];
		}
	};

	for(int i=1; i<=n; i++){
		dp[i][0] = m[1][i];//不分段的情况
	}
	for(int i=1; i<=n; i++){//位数
		for(int j=0; j<i; j++){//分割段数
			for(int k=1; k<i; k++){
				dp[i][j] = max(dp[i][j], dp[k][j-1]*m[k+1][i]);
				//前k个数分割成j-1段，然后最后面乘以k+1到i的数
				//cout<<"i:"<<i<<" j:"<<j<<" dp[i][j]:"<<dp[i][j]<<endl;
			}
		}
	}
	cout<<dp[n][k]<<endl;

	system("pause");  
	return 0;  
}  