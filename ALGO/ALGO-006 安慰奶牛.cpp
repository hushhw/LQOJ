/*
问题描述
Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。道路被用来连接N个牧场，牧场被连续地编号为1到N。每一个牧场都是一个奶牛的家。
FJ计划除去P条道路中尽可能多的道路，但是还要保持牧场之间 的连通性。
你首先要决定那些道路是需要保留的N-1条道路。
第j条双向道路连接了牧场Sj和Ej(1 <= Sj <= N; 1 <= Ej <= N; Sj != Ej)，而且走完它需要Lj的时间。
没有两个牧场是被一条以上的道路所连接。
奶牛们非常伤心，因为她们的交通系统被削减了。
你需要到每一个奶牛的住处去安慰她们。
每次你到达第i个牧场的时候(即使你已经到过)，你必须花去Ci的时间和奶牛交谈。
你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。
在早上 起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次。这样你才能完成你的 交谈任务。
假设Farmer John采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。

输入格式
	第1行包含两个整数N和P。
	接下来N行，每行包含一个整数Ci。
	接下来P行，每行包含三个整数Sj, Ej和Lj。

输出格式
	输出一个整数, 所需要的总时间(包含和在你所在的牧场的奶牛的两次谈话时间)。

样例输入
5 7
10
10
20
6
30
1 2 5
2 3 5
2 4 12
3 4 17
2 5 15
3 5 6
4 5 12	//题目里面少了一行，导致我怎么测试都不对，最后发现收了一行简直气疯，最后在测试数据文件夹里找到的。。。
样例输出
176
数据规模与约定
5 <= N <= 10000，N-1 <= P <= 100000，0 <= Lj <= 1000，1 <= Ci <= 1,000。
*/

/*
分析来自：https://www.cnblogs.com/xl1027515989/archive/2014/03/16/3603151.html
题目的意思不是很清楚，大意就是说：

输入一个无向图，以及每个点安慰奶牛用时间，任务是寻找一个生成树，使你从这个树的某个节点开始按照某种顺序遍历，让这棵树花费的时间最少。
花费时间定义为每条边上的时间和到达某一个节点时（无论你之前是否已经去过）该节点的时间。   

首先我们着眼于生成一棵树。
有点类似与最小生成树但又不是纯粹的最小生成树。然后注意到题目的关键在于遍历整棵树一次。这意味着什么？不就是每条边都会被走两次吗？？！！
然后就是每个点的权值。用草稿纸分析可以得出，树中一个度数为d的节点在遍历的过程中一定走了d次！！！当然，起点会多一次，即d+1次（我们就选最小权值的点当起点）。



首先这个题是最小生成树问题，但是没有现成的生成树，所以我们就先构造一个。
对于每条边，如果选的话，则要耗去来回一趟和访问2个端点所用的的时间总合，所以将图中各个边的权值改为边本来的权值的两倍加上访问两端点的值，这样一棵树就构造好。
至于住在哪间房里面，选择Ci最小的那一间就可以了。
  */

/*代码中涉及的知识点：qsort()对结构体一级排序

struct In
{
double data;
int other;
}s[100]

//按照data的值从小到大将结构体排序,关于结构体内的排序关键数据data的类型可以很多种，参考上面的例子写
int cmp( const void *a ,const void *b)
{
return (*(In *)a).data > (*(In *)b).data ? 1 : -1;
}

qsort(s,100,sizeof(s[0]),cmp);


最后我还是改成了sort()。。。。。
*/

#include <iostream>
#include <string>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int pre[10010];
int s[10010];		//s[]用来存储ci，交流时间

struct IN{
	int a,b;
	int c;
}mp[100010];

int N,P;
/*
int cmp(const void *a,const void *b)
{
	return (*(IN *)a).c - (*(IN *)b).c;
}
*/

bool cmp(IN a, IN b){
	return a.c <b.c;
}

int find(int x){
	int r;
	r=x;
	while(r!=pre[r]) //如果不是根，就去找
		r=pre[r];

	//路径压缩
	int i=x;
	int j;
	while(i!=r){	//如果当前查找的结点x不是根
		j=pre[i];	//用j临时存储
		pre[i]=r;	//更新x的pre前导点直接指向r(前面已经搜过，r即根)
		i=j;		//让i指向其前导点，在下一次循环里面就会更新其前导点指向根
	}
	return r;
}

int krcuskal(){
	int i,j;
	
	memset(pre, 0, sizeof(pre));
	for(i=1; i<=N; i++){
		pre[i]=i;
	}
	int pa,pb,sum=0,count=0;
	for(i=0; i<P; i++){
		pa=find(mp[i].a); //分别查找根
		pb=find(mp[i].b);
		if(pa!=pb){		//发现没有连接
			pre[pa] = pb;
			sum += mp[i].c;
			count++;
		}
	}
	return sum;
}

int main(){
	int i,j;

	scanf("%d%d",&N,&P);	//输入N个牧场，P条道路

	int min=2001;
	for(i=1; i<=N; i++){
		scanf("%d",&s[i]);
		if(s[i]<min)
			min=s[i];		//标记最小ci
	}

	int c;
	for(i=0; i<P; i++){
		scanf("%d%d%d",&mp[i].a, &mp[i].b, &c);
		mp[i].c = 2*c + s[mp[i].a] + s[mp[i].b];
		//每条边，如果选的话，则要消耗来回一趟和访问两个端点所用时间的总和
		//所以将图中各个边的权值改为边本来的权值的两倍加上访问两端点的值
		
	}

	sort(mp, mp+P, cmp);
	//qsort(mp, P, sizeof(mp[0]), cmp);
	//qsort主要根据你给的比较条件给一个快速排序，主要是通过指针移动实现排序功能。排序之后的结果仍然放在原来数组中。
	int sum = krcuskal();
	printf("%d\n", sum+min);
	system("pause");
	return 0;
}