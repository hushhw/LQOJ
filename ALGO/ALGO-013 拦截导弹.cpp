/*
蓝桥杯 ALGO-13 算法训练 拦截导弹
	问题描述
	　　某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：
	虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。
	某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。
	输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，
	如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

输入格式
	一行，为导弹依次飞来的高度
输出格式
	两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数
样例输入
	389 207 155 300 299 170 158 65
样例输出
	6
	2
*/

/*
假如某序列完全递减，则最长递增子序列长度为1，即只有一个最长递减子序列。 
假如某序列完全递增，则最长递增子序列长度为n，即有n个最长递减子序列。（n为该序列长度） 
那么对于某序列有增有减，则该序列所形成的严格单调递增序列必然为其每个互相完全不相同单调递减序列的某一个元素共同构成，
即对于序列100 68 66 56 78 89 66 20 9，其严格单调递增序列为56 78 89。显然56，78，89永远为三个不同的递减序列中的元素。

假如严格单调递增序列的元素不为不同的递减序列的元素。
即某个递减序列贡献了多个元素为严格单调递增序列元素，那么显然这多个元素是单调递增的，与递减序列矛盾。即可证明。
*/

#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#define N 30
using namespace std;

int dp1[N];
int dp2[N];

int main(){
	int a[N];
	int j=0;
	char c;
	while(1){
		cin>>a[j];
		j++;
		c = cin.get();
		if(c=='\n')
			break;
	}

	memset(dp1, 0, sizeof(dp1));
	memset(dp2, 0, sizeof(dp2));
	int max1=-1, max2=-1;
	for(int i=0;i<j;i++){  
		dp1[i]=1;  
		dp2[i]=1;  
		for(int l=0;l<i;l++){  
			if(a[i]<a[l]){  
				dp1[i]=max(dp1[i],dp1[l]+1);  
			}  
			else{  
				dp2[i]=max(dp2[i],dp2[l]+1);  
			}
		}   
		max1=max(max1,dp1[i]);  
		max2=max(max2,dp2[i]);  
	}  

	cout<<max1<<endl;  
	cout<<max2;  
	system("pause");
	return 0;
}